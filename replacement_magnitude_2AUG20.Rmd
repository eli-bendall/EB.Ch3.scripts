---
title: "replacement magnitude_juveniles"
author: "E Bendall & M Bedward"
date: "02/08/2020"
output: word_document
---


```{r setup, include=TRUE, message=FALSE}
knitr::opts_chunk$set(echo = TRUE, fig.width=8, fig.height=6)

library(here)
library(dplyr)
library(ggplot2)
library(mgcv)
library(readxl)
library(stringr)
library(tidyr)
library(bayesplot)
library(brms)
library(tidybayes)
library(RColorBrewer)
library(rstan)
library(splines)
library(forcats)
library(runjags)
runjags.options(modules = "glm")
#library(ggthemes)
library(ggpubr)
#library(egg)

#These options help Stan run faster:

rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

# Make sure the scales package is available (it should be if ggplot is installed)
requireNamespace("scales")

# Default graph theme - white background
theme_set( theme_bw() )

set.seed(42)


# Set to TRUE to force models to be refitted
REFIT_MODELS <- FALSE


# Create a folder for fitted models if one does not already exist
FittedModelsPath <- here("fitted_models")
if (!dir.exists(FittedModelsPath)) {
  dir.create(FittedModelsPath)
}


# Load brms if it is installed (requires Stan software and the rstan package).
# If not installed, HAS_BRMS will be set to FALSE.
HAS_BRMS <- suppressWarnings(
  require("brms", quietly = TRUE)
)


###### Some helper functions #####

# Calculate standard page sizes
pagesize <- function(size = c("A4", "A3", "A2", "A1", "A0"), 
                     orientation = c("portrait", "landscape"),
                     units = c("cm", "mm")) {
  
  size <- match.arg(size)
  orientation <- match.arg(orientation)
  units <- match.arg(units)
  
  alpha <- 1000 * 2^(1/4)
  i <- as.integer(substr(size, 2, 2))
  long <- alpha * 2^(-i/2)
  
  page <- switch(
    orientation,
    portrait = c(width = long / sqrt(2), height = long),
    landscape = c(width = long, height = long / sqrt(2))
  )
  
  page <- round(page)
  if (units == "cm") page <- page / 10
  
  page <- c(as.list(page), units = units)
  class(page) <- "pagesize"
  
  page
}



# Save a graph to a PDF file
gg_pdf <- function(plot, filename, size = pagesize("A4", "landscape", "cm")) {
  
  if (!inherits(size, "pagesize")) stop("The size argument should be a pagesize (list) object")
  
  ggsave(
    filename, 
    plot, 
    width = size$width,
    height = size$height,
    units = size$units)
}


# Calculate highest posterior density interval for a vector of values
hpdi.vec <- function (x, prob = 0.95) {
  n <- length(x)
  if (n <= 1) stop("x must have more than 1 element")
  x <- sort(x)

  gap <- max(1, min(n - 1, round(n * prob)))
  init <- 1:(n - gap)

  inds <- which.min(x[init + gap] - x[init])

  out <- c(lower = x[inds], upper = x[inds + gap])
  out
}

# Function to allow ggplot to use a sqrt scale for positive and negative values
sqrt_abs <- scales::trans_new(name = "sqrt_abs",
                              transform = function(x) sign(x) * sqrt(abs(x)),
                              inverse = function(x) sign(x) * x * x)

```

## Step 1: Run 'site info' markdown before using this code


## Prepare data 

All field data are in a single Excel workbook.

```{r}

ExcelPathData <- here("data_raw", "Eli_field_data30thMAY.xlsx")

ExcelPathBarkTypes <- here("data_raw", "bark3.xlsx")

```


### DBH class definitions (to be used for checking)

```{r}

DBH.classes <- data.frame(
  class = 1:4,
  dbh.min = c(0, 2.5, 10, 20)
)

knitr::kable(DBH.classes)

```




### Recruit levels

This look-up table relates field codes for topkill to aggregated classes that will be used for modelling.

```{r}

# Resprout model levels in order of response severity (low to high)
recruitLevels <- data.frame(
  
  level = c('l',        'c',        'e',        'd',    'ns'),
  
  label = c('resprout', 'resprout', 'resprout', 'dead', 'recruit') )

knitr::kable(recruitLevels)


dbhLevels <- data.frame(
  level = c('4',       '3',           '2',       '1'),

  label = c('mature',  'pole-sized',  'sapling', 'juvenile') )

knitr::kable(dbhLevels)

topkillLevels <- data.frame(
  level = c('intact',  'canopy',  'stem',    'tree', 'topkill'),
  
  label = c('success', 'success', 'success', 'fail', 'fail') )

knitr::kable(topkillLevels)



```


### Small trees

```{r}
dat12 <- read_excel(ExcelPathData, sheet = "class1_2", guess_max = 5000) %>%
  select(siteid = site_id,
         treeid = tree_id,
         species,
         dbhclass = class,
         dbh:dbh5,
         r_type,
         topkill) %>%
  
  
  # Add Excel row number (useful to locate records for checking)
  mutate(xlrow = row_number() + 1) %>%
  
  filter(dbhclass == 1) %>%
  
 
  #filter(dbhclass != 2) %>%
  
  # Attach labels/
  mutate(recruit = factor(r_type, ordered = TRUE,
                      levels = recruitLevels$level,
                      labels = recruitLevels$label)) %>%
  
    # Attach labels/
  mutate(topkill = factor(topkill, ordered = TRUE,
                      levels = topkillLevels$level,
                      labels = topkillLevels$label)) %>%
  


  
    # filter out missing records
  filter(!is.na(r_type)) %>%
  
  #filter(recruit == "recruit")
  filter(recruit != "resprout")

# for some strange reason dbh for small trees is being read in as chracter and must be   converted here. Probably something to do with excel sheet, but upon checking this is not apparent

dat12$dbh <- as.numeric(as.character(dat12$dbh))
  
```


Check for missing values

```{r}
colSums( is.na(dat12) )
```


Calculate single-stem DBH

```{r}

# Function to calculate equivalent single-stem DBH
fn_dbh <- function(...) {
  dbhs <- cbind(...)
  sqrt( rowSums(dbhs^2, na.rm = TRUE) )
}

dat12 <- dat12 %>% 
  mutate(dbhsingle = fn_dbh(dbh, dbh2, dbh3, dbh4, dbh5)) %>%
  
  ## delete unused DBH columns
  
 dplyr::select(-(dbh:dbh5))



```


Check for any trees where the single-stem DBH is below the lower threshold for the recorded DBH class. This might indicate a data entry error. For multi-stem trees, the calculated single-stem diameter is always greater than the largest individual stem diameter.

```{r}

small12 <- dat12 %>%
  left_join(DBH.classes, by = c("dbhclass" = "class")) %>%
  filter(dbhsingle < dbh.min) %>%
  select(-dbh.min)

if (nrow(small12) > 0) {
  knitr::kable(small12)
} else {
  cat("No trees with suspect diameters found")
}

```

*TODO* Eli will check the above records. For the moment we will discard them. ### UPDATED - checked by Eli, some records were fixed for large trees, some records for small trees were missing observations

```{r}

if (nrow(small12) > 0) {
  dat12 <- dat12 %>%
    filter( !(xlrow %in% small12$xlrow) )
}

```

## Stumps and logs

```{r}

 
datST <- read_excel(ExcelPathData, sheet = "class5", guess_max = 2500) %>%
  select(siteid = site_id,
         treeid = tree_id,
         species,
         dbhclass = class,
         dbh:dbh5,
         topkill = topkill_alt,
         r_type) %>%
  
  #Add Excel row number (useful to locate records for checking)
  mutate(xlrow = row_number() + 1) %>%
    
  
  # NOTE: Here we only want records for stumpsthat have been deteermined to be topkilled     during the last fire, i.e. 'topkill_alt'. 
  filter(topkill == "topkill") %>%

  
  # Attach labels/levels
  mutate(topkill = factor(topkill, ordered = TRUE,
                      levels = topkillLevels$level,
                      labels = topkillLevels$label)) %>%
  
    # Attach labels/
  mutate(recruit = factor(r_type, ordered = TRUE,
                      levels = recruitLevels$level,
                      labels = recruitLevels$label)) %>%
  


  # Filter out missing records, NOTE: for some reason in some places there is an error when   'filter' is used, so here it must be 'dplyr::filter'.
  dplyr::filter(!is.na(topkill)) %>%
  dplyr::filter(!is.na(r_type)) %>%
  dplyr::filter(!is.na(dbh)) %>%
    filter(!(dbhclass=='3')) %>%
    filter(!(dbhclass=='4'))



```

## Check for missing values

```{r}

colSums( is.na(datST) )
```
## Calculate single-stem DBH

```{r}

datST <- datST %>% 
  mutate(dbhsingle = fn_dbh(dbh, dbh2, dbh3, dbh4, dbh5)) %>%
         
## NOTE: dbh column has 3 missing values ## Update: Double check this, but should be fixed 
  
  
## delete unused DBH columns

dplyr::select(-(dbh:dbh5))
```


```{r}

smallST <- datST %>%
  left_join(DBH.classes, by = c("dbhclass" = "class")) %>%
  filter(dbhsingle < dbh.min) %>%
  select(-dbh.min)

if (nrow(smallST) > 0) {
  knitr::kable(smallST)
} else {
  cat("No trees with suspect diameters found")
}

```

Eli advises that these zero diameters are to be treated as missing values. We will discard them here:

```{r}

datST <- datST %>%
  filter( !(xlrow %in% smallST$xlrow) )

```


```{r}
na0 <- function(x) ifelse(is.na(x), 0, x)

DAT.all.trees <- bind_rows(
  mutate(dat12, source = "dat12"),
  mutate(datST, source = "datST")) %>%

  # Re-arrange columns a bit
  select(xlrow, treeid, species, starts_with("dbh"), everything()) %>%
  
  
  # Guard against mis-matched species names due to
  # case or spaces
  mutate(species = str_to_title( str_remove_all(species, "\\s+") ) )

```



Check for missing values

```{r}

colSums( is.na(DAT.all.trees) )

```




## Species summary

This generates a summary table showing the number of occurrences (sites) for each DBH class by species.

```{r}

species.summary <- DAT.all.trees %>%
  group_by(species, dbhclass) %>%
  summarize(ntrees = n_distinct(treeid)) %>%
  
  mutate(dbhclass = paste0("class", dbhclass)) %>%
  tidyr::spread(dbhclass, ntrees, fill = 0) %>%

  arrange(species)

```


### Species for modelling

Species category "u" means unknown eucalypt. There are some cases in the tree data (both dat34 and dat12) that need to be checked. For the log data we want to include the "u" cases in the modelling data set.

### Update, species entries have been checked, confirm then "u" must be kept in addition to the fake species "E. unkn", which was created for unknown species of charred logs (i.e. bark type = 'burnt').

```{r}

excluded <- c("A.litt", "A.toru", "B.serr", "C.apet", "C.australis", "Other", "A. deal")

species.summary <- species.summary %>%
  mutate(model = !(species %in% excluded) )

```


### Prepare data for modelling

We will exclude the smallest trees (DBH class 1).

```{r}

dat.model <- DAT.all.trees %>%
  
  # Subset to species to model
  left_join(species.summary %>% select(species, model), 
            by = "species") %>%
  
  filter(model) %>%
  select(-model) 

  
```


Add site attributes. 

*Note:* this relies on the code in document `import_site_data.Rmd` being run first.

```{r}

load( here("data", "sites.RData") )

dat.model <- dat.model %>%
  left_join(
    DAT.sites %>% select(siteid, vegtype,
                         fireclass, firecount,
                         droughtclass, droughtclass2, spei,
                         easting, northing),
    
    by = "siteid"
  )

```


## Models for DSF observations

```{r}

dat.model.r.DSF <- dat.model %>%
  filter(vegtype == "dsf")
 
dat.model.r.DSF.tmp <- dat.model.r.DSF %>%
  mutate(droughtclass = factor(droughtclass, 
                               levels = c("low",         "high"),
                               labels = c("low drought", "high drought"))) %>%
  mutate(fireclass = factor(fireclass, 
                            levels = c("low",     "high"),
                            labels = c("low fire", "high fire")))


```




```{r}

### count

dat.model.r.DSF <- dat.model.r.DSF.tmp %>%
  select(topkill, siteid, source) %>%
  
  group_by(siteid, source) %>%
  
  summarize(nseed = sum(topkill == "success"),
            ndead = sum(topkill == "fail")) %>%
  
  mutate(
    nseed = case_when(source == "dat12" ~ nseed * 4,
                      source == "datST" ~ nseed * 1)) %>%
  
    mutate(
    ndead = case_when(source == "dat12" ~ ndead * 4,
                      source == "datST" ~ ndead * 1)) %>%
  
  select(-(source)) %>%
  
    ungroup()

## remove duplicate rows

dat.model.r.DSF <- dat.model.r.DSF %>%

    group_by(siteid) %>% 
    transmute(nseed=sum(nseed),
              ndead=sum(ndead)) %>%
  
  distinct(siteid, nseed, ndead) %>%

  ungroup()

## calculation

dat.model.r.DSF <- dat.model.r.DSF %>%
    select(siteid, nseed, ndead) %>%
  
  group_by(siteid, nseed, ndead) %>%

  summarize(total = sum(nseed, ndead)) %>%
  mutate(replace_diff = nseed - ndead) %>%
  
  ungroup()

###
  
dat.sitelist <- DAT.sites %>%
  select(siteid, droughtclass, fireclass, vegtype) %>%
  filter(vegtype == "dsf") %>%
  select(-(vegtype))

# Add predictor data
dat.model.r.DSF <- dat.model.r.DSF %>%
 left_join(dat.sitelist %>% distinct(siteid, fireclass, droughtclass), by = "siteid") %>%
  
    tidyr::complete(dat.sitelist, fill = list(nseed = 0, ndead = 0, total = 0, replace_diff = 0)) %>%


  mutate(siteid = factor(siteid),
         isiteid = as.integer(siteid)) %>%
  
    mutate(droughtclass = factor(droughtclass, 
                               levels = c("low",         "high"),
                               labels = c("low drought", "high drought"))) %>%
  mutate(fireclass = factor(fireclass, 
                            levels = c("low",     "high"),
                            labels = c("low fire", "high fire"))) %>%
  
  
    mutate(droughtfire = interaction(droughtclass, fireclass))
```

```{r}
dat.mag <- dat.model.r.DSF %>%
  group_by(droughtfire) %>%
  summarize(replace_diff = mean(replace_diff))
```




## change labels for plotting

```{r fig.height = 4, fig.width = 4}

## re-arrange 'firedrought

dat.model.r.DSF.plot <- dat.model.r.DSF %>%
#  filter(nseed < 170) %>%

 ## Give better labels to droughtfire for plotting

  tidyr::unite(droughtclass_fireclass, droughtclass, fireclass) %>%
  mutate(var = factor(droughtclass_fireclass, levels = c("low drought_low fire", "low drought_high fire", "high drought_low fire", "high drought_high fire"),
                                              labels = c("MD/LF",                "MD/HF",                 "SD/LF",                 "SD/HF")))





```


```{r}

ggplot(dat.model.r.DSF, aes(x = replace_diff, color = droughtfire)) +
  geom_density()
```

### Data exploration DSF

```{r}

DAT.DSF <- dat.model.r.DSF

TreatLookup <- data.frame(droughtfire = levels(DAT.DSF$droughtfire)) %>%
  
  mutate(
    drought.label = ifelse(str_detect(droughtfire, "low.drought"), "MD", "SD"),
    fire.label = ifelse(str_detect(droughtfire, "low.fire"), "LF", "HF"),
    
    treat.label = paste(drought.label, fire.label, sep = "_"),
    
    treat.factor = factor(treat.label, 
                          levels = c("MD_LF", "MD_HF", "SD_LF", "SD_HF")),
    
    treat.index = as.integer(treat.factor)
  ) %>%
  
  arrange(treat.index)


dat.gg <- DAT.DSF %>%
  mutate(state = ifelse(replace_diff < 0, "deficit", "replacement")) %>%
  left_join(TreatLookup, by = "droughtfire")


ggplot(data = dat.gg) +
  geom_jitter(aes(x = treat.factor, y = replace_diff, shape = state),
              width = 0.1, height = 0, size = 3) +
  
  scale_shape_manual("State", values = c(1, 16)) +
  
  scale_y_continuous(trans = sqrt_abs, breaks = c(-50, -10, 0, 10, 50, 100, 500, 1000)) +
  
  labs(x = "", y = "Replacement",
       title = "Juvenile replacement in DSF sites") +
  
  theme(panel.grid.minor = element_blank())

```

### Model probability of deficit for drought-fire combinations

Here we model the probability that the number of live seedlings will be less than the number of dead juveniles, i.e. a recruitment deficit.

The model is a simple logistic regression. Because of the relatively small number of sites within each drought / fire category, we fit a multi-level model with the prior for probability of decline within each category linked to an overall prior.

```{r}

dat.model.prob <- DAT.DSF %>%
  mutate(deficit = as.integer(replace_diff < 0)) %>%
  left_join(TreatLookup, by = "droughtfire") %>%
  select(deficit, treatment = treat.index)


model.DSF.deficit.code <- "model {
  for (i in 1:length(deficit)) {
    deficit[i] ~ dbern(p[i])
    logit(p[i]) <- alpha[treatment[i]]
  }
  
  # Priors for prob of deficit within drought-fire categories
  for (i in 1:4) {
    alpha[i] ~ dnorm(alpha0, 1)
  }

  # Overall prior for prob of deficit
  alpha0 ~ dnorm(0, 1)
}"


model.DSF.deficit <- run.jags(model.DSF.deficit.code, 
                              monitor = c("alpha", "alpha0"), 
                              data = dat.model.prob,
                              n.chains = 4)

post <- as.matrix(model.DSF.deficit$mcmc)

# Convert alpha values to probabilities
post <- plogis(post)

# Set treatment labels as names of treatment columns
flag <- str_detect(colnames(post), "\\[\\d\\]")
index <- as.integer(str_extract(colnames(post)[flag], "\\d"))

colnames(post)[flag] <- TreatLookup$treat.label[index]

```


Quick look at bounds for probability of decline.

```{r}

dat.stats <- t( apply(post, 2, quantile, 
                      probs = c(0.025, 0.25, 0.5, 0.75, 0.975)) )

p.overall <- dat.stats["alpha0", "50%"]
cat("Median probability over all sites:", round(p.overall, digits = 2))

```

```{r}

dat.stats <- dat.stats %>%
  as.data.frame() %>%
  
  mutate(treat.label = rownames(.)) %>%
  
  filter(treat.label %in% TreatLookup$treat.label) %>%
  
  rename(lwr95 = `2.5%`, lwr50 = `25%`, 
         mid = `50%`,
         upr50 = `75%`, upr95 = `97.5%`) %>%
  
  left_join(TreatLookup %>% select(treat.label, treat.factor),
            by = "treat.label")


ggplot(data = dat.stats, aes(x = treat.factor)) +
  geom_linerange(aes(ymin = lwr95, ymax = upr95),
                 size = 1) +
  
  geom_linerange(aes(ymin = lwr50, ymax = upr50),
                 size = 3) +
  
  labs(x = "", y = "Probability",
       title = "DSF sites: Probability of deficit in post-fire recruitment",
       subtitle = paste("Intervals are 50% and 95% bounds."))

```


### Model the magnitude of replacement ### V1 with overestimation

Now we model the expected level of replacement. We have positive and negative observed values for sites (variable `replace_diff`), so a standard count model will not work. All drought - fire combinations exhibit a right-tailed distribution of values (see data graph above). We will take advantage of this, and fit a negative binomial count model to the replacement values, after shifting them to the right to render them all positive. 

Because of the right-tailed pattern of data, the mean of the fitted negative binomial distribution for each treatment will not be a useful measure of expected value. Instead, we will have the model calculate the median of the negative binomial distribution at each iteration. The posterior medians will then be shifted back to the original scale.

```{r}

Shift <- abs(min(DAT.DSF$replace_diff)) + 1

dat.model.mag <- DAT.DSF %>%
  left_join(TreatLookup, by = "droughtfire") %>%
  mutate(y = Shift + replace_diff) %>%
  select(y, treatment = treat.index)


model.DSF.replace.code <- "model {
  for (i in 1:length(y)) {
    y[i] ~ dnegbin(p[treatment[i]], sz[treatment[i]])
  }
  
  for (i in 1:4) {
    p[i] <- sz[i] / (sz[i] + mu[i])
    sz[i] ~ dexp(1 / sz0)
    mu[i] ~ dexp(1 / mu0)
    
    # monitor median value
    mid[i] <- qnegbin(0.5, p[i], sz[i])
  }
  
  sz0 ~ dexp(0.1)
  mu0 ~ dexp(0.01)
}"


model.DSF.replace <- run.jags(model.DSF.replace.code, 
                              monitor = c("mu", "sz", "mid"), 
                              data = dat.model.mag, 
                              n.chains = 4)


post <- as.matrix(model.DSF.replace$mcmc)

# We are only interested in the columns for median values
ii <- str_detect(colnames(post), "^mid\\[")
post <- post[, ii]

# Shift values back to original scale and fix column names
post <- post - Shift
colnames(post) <- TreatLookup$treat.label

```


```{r}

dat.stats <- t( apply(post, 2, quantile, 
                      probs = c(0.025, 0.25, 0.5, 0.75, 0.975)) )

dat.stats <- dat.stats %>%
  as.data.frame() %>%
  
  mutate(treat.label = rownames(.)) %>%
  
  filter(treat.label %in% TreatLookup$treat.label) %>%
  
  rename(lwr95 = `2.5%`, lwr50 = `25%`, 
         mid = `50%`,
         upr50 = `75%`, upr95 = `97.5%`) %>%
  
  left_join(TreatLookup %>% select(treat.label, treat.factor),
            by = "treat.label")


ggplot() +
  geom_linerange(data = dat.stats, 
                 aes(x = treat.factor, ymin = lwr95, ymax = upr95),
                 size = 1) +
  
  geom_linerange(data = dat.stats, 
                 aes(x = treat.factor, ymin = lwr50, ymax = upr50),
                 size = 3) +
  
  
  labs(x = "", y = "Replacement",
       title = "DSF sites: Median expected replacement",
       subtitle = paste("Intervals are 50% and 95% bounds.")) +
  
  theme(panel.grid.minor = element_blank())

```

Same graph with observed data for checking purposes. Y-axis has square-root scale so that the intervals are not minute.

```{r}

dat.obs <- DAT.DSF %>%
  left_join(TreatLookup, by = "droughtfire") %>%
  select(treat.factor, replace_diff) %>%
  mutate(state = ifelse(replace_diff < 0, "deficit", "replacement"))


last_plot() +
  geom_jitter(dat = dat.obs,
              aes(x = treat.factor, y = replace_diff, shape = state),
              width = 0.2, height = 0) +
  
  scale_shape_manual("State", values = c(1, 16)) +
  
  scale_y_continuous(trans = sqrt_abs)

```

### Model the magnitude of replacement ## v2

Now we model the expected level of replacement. We have positive and negative observed values for sites (variable `replace_diff`), so a standard count model will not work. Accordingly, we treat the replacement values as continuous and deal with the several large outlier values by modelling them with a heavy-tailed distribution (a t-distribution with shape parameter learned by the model). The mean and standard deviation of replacement values are modelled hierarchically, with each treatment parameter drawn from a top-level distribution. The common shape parameter applies across treatments to aid model convergence.

```{r}

dat.model.DSF <- DAT.DSF %>%
  left_join(TreatLookup, by = "droughtfire") %>%
  select(y = replace_diff, treatment = treat.index)


model.replace.code <- "model {
  for (i in 1:length(y)) {
    y[i] ~ dt(mu[treatment[i]], tau[treatment[i]], shape)
  }
  
  for (i in 1:4) {
    mu[i] ~ dnorm(mu.all, 0.01)
    sd[i] ~ dexp(1 / sd.all)
    tau[i] <- pow(sd[i], -2)
  }

  mu.all ~ dnorm(0, 0.001)
  sd.all ~ dexp(0.01)
  
  shape0 ~ dexp(1 / 10)
  shape <- shape0 + 1
}"


model.DSF.replace <- run.jags(model.replace.code, 
                              monitor = c("mu", "sd", "shape"), 
                              data = dat.model.DSF, 
                              n.chains = 4, sample = 5000, thin = 5,
                              method = "parallel")


post <- as.matrix(model.DSF.replace$mcmc)

# We are only interested in the columns for mean values
ii <- str_detect(colnames(post), "^mu\\[")
post <- post[, ii]

colnames(post) <- TreatLookup$treat.label

```

Probability of decline (mean replacement < 0)

```{r}

apply(post, 2, function(x) mean(x < 0))

```

```{r}

dat.stats <- t( apply(post, 2, quantile, 
                      probs = c(0.025, 0.25, 0.5, 0.75, 0.975)) )

dat.stats <- dat.stats %>%
  as.data.frame() %>%
  
  mutate(treat.label = rownames(.)) %>%
  
  filter(treat.label %in% TreatLookup$treat.label) %>%
  
  rename(lwr95 = `2.5%`, lwr50 = `25%`, 
         mid = `50%`,
         upr50 = `75%`, upr95 = `97.5%`) %>%
  
  left_join(TreatLookup %>% select(treat.label, treat.factor),
            by = "treat.label")


ggplot() +
  geom_linerange(data = dat.stats, 
                 aes(x = treat.factor, ymin = lwr95, ymax = upr95),
                 size = 1) +
  
  geom_linerange(data = dat.stats, 
                 aes(x = treat.factor, ymin = lwr50, ymax = upr50),
                 size = 3) +
  
  labs(x = "", y = "Replacement",
       title = "DSF sites: Mean expected replacement",
       subtitle = paste("Intervals are 50% and 95% bounds.")) +
  
  theme(panel.grid.minor = element_blank())

```

Same graph with observed data for checking purposes. Y-axis has square-root scale so that the intervals are not minute.

```{r}

dat.obs <- DAT.DSF %>%
  left_join(TreatLookup, by = "droughtfire") %>%
  select(treat.factor, replace_diff) %>%
  mutate(state = ifelse(replace_diff < 0, "deficit", "replacement"))


last_plot() +
  geom_jitter(dat = dat.obs,
              aes(x = treat.factor, y = replace_diff, shape = state),
              width = 0.2, height = 0) +
  
  scale_shape_manual("State", values = c(1, 16)) +
  
  scale_y_continuous(trans = sqrt_abs, breaks = c(-10, 0, 10, 50, 100, 500, 1000))

```


### DSF predictions


```{r}


effect1 <- as.data.frame(post) %>%
    mutate(mild_low = MD_LF,
         mild_high = MD_HF,
         severe_low = SD_LF,
         severe_high = SD_HF)


```



```{r}

head(effect1)

```



```{r}
## calculate probability estimates

diff1 <- effect1 %>%
  mutate(diff1_MD_LF = MD_LF,
         diff1_MD_HF = MD_HF,
         diff1_SD_LF = SD_LF,
         diff1_SD_HF = SD_HF) %>%
  
  select(starts_with("diff1"))

head(diff1)

```

## calculate probability estimates

```{r}


## Calculate predicted difference

## diff drought

diff2 <- effect1 %>%
  
  mutate(diff2_low = severe_low - mild_low,
         diff2_high = severe_high - mild_high) %>%
  
  select(starts_with("diff2"))

diff3 <- effect1 %>%
  
  mutate(diff3_low = (severe_low - mild_low) / mild_low * 100,
         diff3_high = (severe_high - mild_high) / mild_high * 100) %>%
  
  select(starts_with("diff3"))

## diff fire


diff2.a <- effect1 %>%
  
  mutate(diff2a_mild = mild_high - mild_low,
         diff2a_severe = severe_high - severe_low) %>%
  
  select(starts_with("diff2a"))

diff3.a <- effect1 %>%
  
  mutate(diff3a_mild = (mild_high - mild_low) / mild_low * 100,
         diff3a_severe = (severe_high - severe_low) / severe_low * 100) %>%
  
  select(starts_with("diff3a"))

## diff severe conditions

diff3.s <- effect1 %>%
  
  mutate(diff3s_mild = (severe_high - mild_low) / mild_low * 100) %>%
  
  select(starts_with("diff3s"))

```





```{r}
# convert to long format for ggplot
dat.gg1 <- diff1 %>%
  tidyr::gather(var, diff1) %>%
  mutate(var = factor(str_replace(var, "diff1_", ""))) %>%
  mutate(var = factor(str_replace(var, "_", "/"))) %>%
  mutate(var = factor(var, levels = c("MD/LF", "MD/HF", "SD/LF", "SD/HF"), 
                           labels = c("MD/LF", "MD/HF", "SD/LF", "SD/HF")))


x.stats1 <- dat.gg1 %>%
  group_by(var) %>%
    summarize(mid = median(diff1),
            lwr95 = hpdi.vec(diff1, 0.95)[1],
            upr95 = hpdi.vec(diff1, 0.95)[2],
            lwr50 = hpdi.vec(diff1, 0.50)[1],
            upr50 = hpdi.vec(diff1, 0.50)[2])

# convert to long format for ggplot
dat.gg2 <- diff2 %>%
  tidyr::gather(var, diff2) %>%
  mutate(var = factor(str_replace(var, "diff2_", ""))) %>%
  mutate(var = factor(str_replace(var, "_", "/")))


  
x.stats2 <- dat.gg2 %>%
  group_by(var) %>%
    summarize(mid = median(diff2),
            lwr95 = hpdi.vec(diff2, 0.95)[1],
            upr95 = hpdi.vec(diff2, 0.95)[2],
            lwr50 = hpdi.vec(diff2, 0.50)[1],
            upr50 = hpdi.vec(diff2, 0.50)[2]) %>%
      mutate(var = factor(var, levels = c("low", "high"), 
                             labels = c("low", "high")))

# convert to long format for ggplot
dat.gg3 <- diff3 %>%
  tidyr::gather(var, diff3) %>%
  mutate(var = factor(str_replace(var, "diff3_", ""))) %>%
  mutate(var = factor(str_replace(var, "_", "/")))


  
x.stats3<- dat.gg3 %>%
  group_by(var) %>%
    summarize(mid = median(diff3),
            lwr95 = hpdi.vec(diff3, 0.95)[1],
            upr95 = hpdi.vec(diff3, 0.95)[2],
            lwr50 = hpdi.vec(diff3, 0.50)[1],
            upr50 = hpdi.vec(diff3, 0.50)[2])

# convert to long format for ggplot
dat.gg2.a <- diff2.a %>%
  tidyr::gather(var, diff2a) %>%
  mutate(var = factor(str_replace(var, "diff2a_", ""))) %>%
  mutate(var = factor(str_replace(var, "_", "/")))


  
x.stats2.a <- dat.gg2.a %>%
  group_by(var) %>%
    summarize(mid = median(diff2a),
            lwr95 = hpdi.vec(diff2a, 0.95)[1],
            upr95 = hpdi.vec(diff2a, 0.95)[2],
            lwr50 = hpdi.vec(diff2a, 0.50)[1],
            upr50 = hpdi.vec(diff2a, 0.50)[2])

# convert to long format for ggplot
dat.gg3.a <- diff3.a %>%
  tidyr::gather(var, diff3a) %>%
  mutate(var = factor(str_replace(var, "diff3a_", ""))) %>%
  mutate(var = factor(str_replace(var, "_", "/")))


  
x.stats3.a <- dat.gg3.a %>%
  group_by(var) %>%
    summarize(mid = median(diff3a),
            lwr95 = hpdi.vec(diff3a, 0.95)[1],
            upr95 = hpdi.vec(diff3a, 0.95)[2],
            lwr50 = hpdi.vec(diff3a, 0.50)[1],
            upr50 = hpdi.vec(diff3a, 0.50)[2])

# convert to long format for ggplot
dat.gg3.s <- diff3.s %>%
  tidyr::gather(var, diff3s) %>%
  mutate(var = factor(str_replace(var, "diff3s_", ""))) %>%
  mutate(var = factor(str_replace(var, "_", "/")))


  
x.stats3.s <- dat.gg3.s %>%
  group_by(var) %>%
    summarize(mid = median(diff3s),
            lwr95 = hpdi.vec(diff3s, 0.95)[1],
            upr95 = hpdi.vec(diff3s, 0.95)[2],
            lwr50 = hpdi.vec(diff3s, 0.50)[1],
            upr50 = hpdi.vec(diff3s, 0.50)[2])


```

```{r}
dat.obs <- dat.obs %>%
  mutate(var = treat.factor) %>%
  mutate(var = factor(str_replace(var, "_", "/")))
```


```{r fig.height = 3, fig.width = 3}
library(ggthemes)

rhg_cols2 <- c("MD/LF" = "#1b9e77", "MD/HF" = "#d95f02", "SD/LF" = "#7570b3", "SD/HF" = "#e7298a")


My_Theme = theme(
  plot.title = element_text(size = 11.5, face = "bold", hjust = 0.5),
  axis.title.y = element_text(size = 11.5, face = "bold"),
  axis.text.y = element_text(size = 9.5, margin = unit(c(0.1, 0.1, 0.1, -0.2), "cm")),
  axis.text.x = element_blank(),
  axis.title.x = element_text(size = 11.5, face = "bold", vjust = -1.8),
  strip.text.x = element_text(size = 10.5),
  strip.text.y = element_text(size = 10.5),
  strip.text = element_text(size = 10.5),
  strip.background = element_blank(),
  panel.background = element_blank(),
  strip.placement = "inside",
  axis.ticks.length = unit(-0.07, "cm"),
  axis.ticks = element_line(size = 0.8),
  panel.grid.minor.x = element_blank(),
  panel.grid.major.x = element_blank(),
  panel.grid.minor.y = element_blank(),
  panel.grid.major.y = element_blank(),
  legend.position = "bottom",
  legend.title = element_text(size = 8.5, hjust = 0.6, face = "bold"),
  legend.text = element_text(size = 7.5),
  legend.key.width = unit(0.5, "cm"),
  legend.background = element_blank(),
  plot.margin = unit(c(5.5, 4, 6.5, 4), "pt"))


DSF.replace_mag_jags <- ggplot(data = dat.gg1, aes (x = var)) +
  
 My_Theme +

  
  geom_linerange(data = x.stats1, aes(ymin = lwr95, ymax = upr95),
               size = 0.5) +
 
  geom_linerange(data = x.stats1, aes(ymin = lwr50, ymax = upr50),
               size = 5, show.legend = FALSE) +
  
  geom_linerange(data = x.stats1, aes(ymin = lwr50+0.3, ymax = upr50-0.3, color = var),
               size = 4, show.legend = FALSE) +
 
 scale_color_manual(values = rhg_cols2) +
 
  labs(y = "", x = "", title = "Replacement") +
  
  
  geom_hline(yintercept = 0, linetype = "dotted") +
  

   
   ggsave("DSF.replace_mag_jags.png", width = 3.4, height = 3)

DSF.replace_mag_jags
 
```


Probability 

```{r}

means <- dat.gg1 %>%
  group_by(var) %>%
  summarize(prob = mean(diff1))

knitr::kable(means, digits = 3)

```

```{r}
x <- dat.gg1 %>%
  group_by(var) %>%
  
  summarize(lwr95 = hpdi.vec(diff1, 0.95)[1],
            lwr50 = hpdi.vec(diff1, 0.5)[1],
            mid = median(diff1),
            upr50 = hpdi.vec(diff1, 0.5)[2],
            upr95 = hpdi.vec(diff1, 0.95)[2])

knitr::kable(x, digits = 3)
```









```{r}
### DSF probability of decline

apply(effect1, 2, function(x) mean(x < 0))
```






diff drought num

```{r}

dat.gg2 %>%
  group_by(var) %>%
  summarize(prob = median(diff2))

```


diff fire num

```{r}

dat.gg2.a %>%
  group_by(var) %>%
  summarize(prob = median(diff2a))

```



## Models for WSF observations

```{r}

dat.model.r.WSF <- dat.model %>%
  filter(vegtype == "wsf")
 
dat.model.r.WSF.tmp <- dat.model.r.WSF %>%
  mutate(droughtclass = factor(droughtclass, 
                               levels = c("low",         "high"),
                               labels = c("low drought", "high drought"))) %>%
  mutate(fireclass = factor(fireclass, 
                            levels = c("low",     "high"),
                            labels = c("low fire", "high fire")))


```




```{r}
dat.model.r.WSF <- dat.model.r.WSF.tmp %>%
  select(topkill, siteid, source) %>%
  
  group_by(siteid, source) %>%
  
  summarize(nseed = sum(topkill == "success"),
            ndead = sum(topkill == "fail")) %>%
  
  mutate(
    nseed = case_when(source == "dat12" ~ nseed * 4,
                      source == "datST" ~ nseed * 1)) %>%
  
    mutate(
    ndead = case_when(source == "dat12" ~ ndead * 4,
                      source == "datST" ~ ndead * 1)) %>%
  
  select(-(source)) %>%
  
    ungroup()

dat.model.r.WSF <- dat.model.r.WSF %>%

    group_by(siteid) %>% 
    transmute(nseed=sum(nseed),
              ndead=sum(ndead)) %>%
  
  distinct(siteid, nseed, ndead) %>%

  ungroup()

dat.model.r.WSF <- dat.model.r.WSF %>%
    select(siteid, nseed, ndead) %>%
  
  group_by(siteid, nseed, ndead) %>%

  summarize(total = sum(nseed, ndead)) %>%
  mutate(replace_diff = nseed - ndead) %>%
  
  ungroup()
  
dat.sitelist <- DAT.sites %>%
  select(siteid, droughtclass, fireclass, vegtype) %>%
  filter(vegtype == "wsf") %>%
  select(-(vegtype))

# Add predictor data
dat.model.r.WSF <- dat.model.r.WSF %>%
 left_join(dat.sitelist %>% distinct(siteid, fireclass, droughtclass), by = "siteid") %>%
  
    tidyr::complete(dat.sitelist, fill = list(nseed = 0, ndead = 0, nsprout = 0, total = 0, replace_diff = 0)) %>%

  mutate(siteid = factor(siteid),
         isiteid = as.integer(siteid)) %>%
  
    mutate(droughtclass = factor(droughtclass, 
                               levels = c("low",         "high"),
                               labels = c("low drought", "high drought"))) %>%
  mutate(fireclass = factor(fireclass, 
                            levels = c("low",     "high"),
                            labels = c("low fire", "high fire"))) %>%
  
  
    mutate(droughtfire = interaction(droughtclass, fireclass)) 
```


```{r fig.height = 4, fig.width = 4}

## re-arrange 'firedrought

dat.model.r.WSF.plot <- dat.model.r.WSF %>%


 ## Give better labels to droughtfire for plotting

  tidyr::unite(droughtclass_fireclass, droughtclass, fireclass) %>%
  mutate(var = factor(droughtclass_fireclass, levels = c("low drought_low fire", "low drought_high fire", "high drought_low fire", "high drought_high fire"),
                                              labels = c("MD/LF",                "MD/HF",                 "SD/LF",                 "SD/HF")))





```

```{r}
ggplot(dat.model.r.WSF, aes(x = replace_diff, color = droughtfire)) +
  geom_density()
```

### Data exploration WSF

```{r}

DAT.WSF <- dat.model.r.WSF

TreatLookup <- data.frame(droughtfire = levels(DAT.WSF$droughtfire)) %>%
  
  mutate(
    drought.label = ifelse(str_detect(droughtfire, "low.drought"), "MD", "SD"),
    fire.label = ifelse(str_detect(droughtfire, "low.fire"), "LF", "HF"),
    
    treat.label = paste(drought.label, fire.label, sep = "_"),
    
    treat.factor = factor(treat.label, 
                          levels = c("MD_LF", "MD_HF", "SD_LF", "SD_HF")),
    
    treat.index = as.integer(treat.factor)
  ) %>%
  
  arrange(treat.index)


dat.gg <- DAT.WSF %>%
  mutate(state = ifelse(replace_diff < 0, "deficit", "replacement")) %>%
  left_join(TreatLookup, by = "droughtfire")


ggplot(data = dat.gg) +
  geom_jitter(aes(x = treat.factor, y = replace_diff, shape = state),
              width = 0.1, height = 0, size = 3) +
  
  scale_shape_manual("State", values = c(1, 16)) +
  
  scale_y_continuous(trans = sqrt_abs, breaks = c(-50, -10, 0, 10, 50, 100, 500, 1000)) +
  
  labs(x = "", y = "Replacement",
       title = "Juvenile replacement in WSF sites") +
  
  theme(panel.grid.minor = element_blank())

```

### Model probability of deficit for drought-fire combinations

Here we model the probability that the number of live seedlings will be less than the number of dead juveniles, i.e. a recruitment deficit.

The model is a simple logistic regression. Because of the relatively small number of sites within each drought / fire category, we fit a multi-level model with the prior for probability of decline within each category linked to an overall prior.

```{r}

dat.model.prob <- DAT.WSF %>%
  mutate(deficit = as.integer(replace_diff < 0)) %>%
  left_join(TreatLookup, by = "droughtfire") %>%
  select(deficit, treatment = treat.index)


model.WSF.deficit.code <- "model {
  for (i in 1:length(deficit)) {
    deficit[i] ~ dbern(p[i])
    logit(p[i]) <- alpha[treatment[i]]
  }
  
  # Priors for prob of deficit within drought-fire categories
  for (i in 1:4) {
    alpha[i] ~ dnorm(alpha0, 1)
  }

  # Overall prior for prob of deficit
  alpha0 ~ dnorm(0, 1)
}"


model.WSF.deficit <- run.jags(model.WSF.deficit.code, 
                              monitor = c("alpha", "alpha0"), 
                              data = dat.model.prob,
                              n.chains = 4)

post <- as.matrix(model.WSF.deficit$mcmc)

# Convert alpha values to probabilities
post <- plogis(post)

# Set treatment labels as names of treatment columns
flag <- str_detect(colnames(post), "\\[\\d\\]")
index <- as.integer(str_extract(colnames(post)[flag], "\\d"))

colnames(post)[flag] <- TreatLookup$treat.label[index]

```


Quick look at bounds for probability of decline.

```{r}

dat.stats <- t( apply(post, 2, quantile, 
                      probs = c(0.025, 0.25, 0.5, 0.75, 0.975)) )

p.overall <- dat.stats["alpha0", "50%"]
cat("Median probability over all sites:", round(p.overall, digits = 2))

```

```{r}

dat.stats <- dat.stats %>%
  as.data.frame() %>%
  
  mutate(treat.label = rownames(.)) %>%
  
  filter(treat.label %in% TreatLookup$treat.label) %>%
  
  rename(lwr95 = `2.5%`, lwr50 = `25%`, 
         mid = `50%`,
         upr50 = `75%`, upr95 = `97.5%`) %>%
  
  left_join(TreatLookup %>% select(treat.label, treat.factor),
            by = "treat.label")


ggplot(data = dat.stats, aes(x = treat.factor)) +
  geom_linerange(aes(ymin = lwr95, ymax = upr95),
                 size = 1) +
  
  geom_linerange(aes(ymin = lwr50, ymax = upr50),
                 size = 3) +
  
  labs(x = "", y = "Probability",
       title = "WSF sites: Probability of deficit in post-fire recruitment",
       subtitle = paste("Intervals are 50% and 95% bounds."))

```


### Model the magnitude of replacement ## v1

Now we model the expected level of replacement. We have positive and negative observed values for sites (variable `replace_diff`), so a standard count model will not work. All drought - fire combinations exhibit a right-tailed distribution of values (see data graph above). We will take advantage of this, and fit a negative binomial count model to the replacement values, after shifting them to the right to render them all positive. 

Because of the right-tailed pattern of data, the mean of the fitted negative binomial distribution for each treatment will not be a useful measure of expected value. Instead, we will have the model calculate the median of the negative binomial distribution at each iteration. The posterior medians will then be shifted back to the original scale.

```{r}

Shift <- abs(min(DAT.WSF$replace_diff)) + 1

dat.model.mag <- DAT.WSF %>%
  left_join(TreatLookup, by = "droughtfire") %>%
  mutate(y = Shift + replace_diff) %>%
  select(y, treatment = treat.index)


model.WSF.replace.code <- "model {
  for (i in 1:length(y)) {
    y[i] ~ dnegbin(p[treatment[i]], sz[treatment[i]])
  }
  
  for (i in 1:4) {
    p[i] <- sz[i] / (sz[i] + mu[i])
    sz[i] ~ dexp(1 / sz0)
    mu[i] ~ dexp(1 / mu0)
    
    # monitor median value
    mid[i] <- qnegbin(0.5, p[i], sz[i])
  }
  
  sz0 ~ dexp(0.1)
  mu0 ~ dexp(0.01)
}"


model.WSF.replace <- run.jags(model.WSF.replace.code, 
                              monitor = c("mu", "sz", "mid"), 
                              data = dat.model.mag, 
                              n.chains = 4)


post <- as.matrix(model.WSF.replace$mcmc)

# We are only interested in the columns for median values
ii <- str_detect(colnames(post), "^mid\\[")
post <- post[, ii]

# Shift values back to original scale and fix column names
post <- post - Shift
colnames(post) <- TreatLookup$treat.label

```


```{r}

dat.stats <- t( apply(post, 2, quantile, 
                      probs = c(0.025, 0.25, 0.5, 0.75, 0.975)) )

dat.stats <- dat.stats %>%
  as.data.frame() %>%
  
  mutate(treat.label = rownames(.)) %>%
  
  filter(treat.label %in% TreatLookup$treat.label) %>%
  
  rename(lwr95 = `2.5%`, lwr50 = `25%`, 
         mid = `50%`,
         upr50 = `75%`, upr95 = `97.5%`) %>%
  
  left_join(TreatLookup %>% select(treat.label, treat.factor),
            by = "treat.label")


ggplot() +
  geom_linerange(data = dat.stats, 
                 aes(x = treat.factor, ymin = lwr95, ymax = upr95),
                 size = 1) +
  
  geom_linerange(data = dat.stats, 
                 aes(x = treat.factor, ymin = lwr50, ymax = upr50),
                 size = 3) +
  
  #scale_y_continuous(trans = sqrt_abs,
  #                   breaks = c(-10, 0, 10, 50, 100, 1000)) +
  
  labs(x = "", y = "Replacement",
       title = "WSF sites: Median expected replacement",
       subtitle = paste("Intervals are 50% and 95% bounds.")) +
  
  theme(panel.grid.minor = element_blank())

```

Same graph with observed data for checking purposes. Y-axis has square-root scale so that the intervals are not minute.

```{r}

dat.obs <- DAT.WSF %>%
  left_join(TreatLookup, by = "droughtfire") %>%
  select(treat.factor, replace_diff) %>%
  mutate(state = ifelse(replace_diff < 0, "deficit", "replacement"))


last_plot() +
  geom_jitter(dat = dat.obs,
              aes(x = treat.factor, y = replace_diff, shape = state),
              width = 0.2, height = 0) +
  
  scale_shape_manual("State", values = c(1, 16)) +
  
  scale_y_continuous(trans = sqrt_abs)

```


### Model the magnitude of replacement ### v2

```{r}

dat.model.WSF <- DAT.WSF %>%
  left_join(TreatLookup, by = "droughtfire") %>%
  select(y = replace_diff, treatment = treat.index)


model.WSF.replace <- run.jags(model.replace.code, 
                              monitor = c("mu", "sd", "shape"), 
                              data = dat.model.WSF, 
                              n.chains = 4, sample = 5000, thin = 5,
                              method = "parallel")


post <- as.matrix(model.WSF.replace$mcmc)

# We are only interested in the columns for mean values
ii <- str_detect(colnames(post), "^mu\\[")
post <- post[, ii]

colnames(post) <- TreatLookup$treat.label

```


Probability of decline (mean replacement < 0)

```{r}

apply(post, 2, function(x) mean(x < 0))

```


```{r}

dat.stats <- t( apply(post, 2, quantile, 
                      probs = c(0.025, 0.25, 0.5, 0.75, 0.975)) )

dat.stats <- dat.stats %>%
  as.data.frame() %>%
  
  mutate(treat.label = rownames(.)) %>%
  
  filter(treat.label %in% TreatLookup$treat.label) %>%
  
  rename(lwr95 = `2.5%`, lwr50 = `25%`, 
         mid = `50%`,
         upr50 = `75%`, upr95 = `97.5%`) %>%
  
  left_join(TreatLookup %>% select(treat.label, treat.factor),
            by = "treat.label")


ggplot() +
  geom_linerange(data = dat.stats, 
                 aes(x = treat.factor, ymin = lwr95, ymax = upr95),
                 size = 1) +
  
  geom_linerange(data = dat.stats, 
                 aes(x = treat.factor, ymin = lwr50, ymax = upr50),
                 size = 3) +
  
  labs(x = "", y = "Replacement",
       title = "WSF sites: Mean expected replacement",
       subtitle = paste("Intervals are 50% and 95% bounds.")) +
  
  theme(panel.grid.minor = element_blank())

```


Same graph with observed data for checking purposes. Y-axis has square-root scale so that the intervals are not minute.

```{r}

dat.obs <- DAT.WSF %>%
  left_join(TreatLookup, by = "droughtfire") %>%
  select(treat.factor, replace_diff) %>%
  mutate(state = ifelse(replace_diff < 0, "deficit", "replacement"))


last_plot() +
  geom_jitter(dat = dat.obs,
              aes(x = treat.factor, y = replace_diff, shape = state),
              width = 0.2, height = 0) +
  
  scale_shape_manual("State", values = c(1, 16)) +
  
  scale_y_continuous(trans = sqrt_abs, breaks = c(-10, 0, 10, 50, 100, 500, 1000))

```

### WSF predictions


```{r}


effect1 <- as.data.frame(post) %>%
    mutate(mild_low = MD_LF,
         mild_high = MD_HF,
         severe_low = SD_LF,
         severe_high = SD_HF)



```



```{r}

head(effect1)

```
##means
```{r}
effect1 %>%
  summarize(median(severe_high), median(severe_low), median(mild_high), median(mild_low))
```


## calculate probability estimates

```{r}
diff1 <- effect1 %>%
  mutate(diff1_MD_LF = mild_low,
         diff1_MD_HF = mild_high,
         diff1_SD_LF = severe_low,
         diff1_SD_HF = severe_high) %>%
  
  select(starts_with("diff1"))

head(diff1)


## Calculate predicted difference

## diff drought

diff2 <- effect1 %>%
  
  mutate(diff2_low = severe_low - mild_low,
         diff2_high = severe_high - mild_high) %>%
  
  select(starts_with("diff2"))

diff3 <- effect1 %>%
  
  mutate(diff3_low = (severe_low - mild_low) / mild_low * 100,
         diff3_high = (severe_high - mild_high) / mild_high * 100) %>%
  
  select(starts_with("diff3"))

## diff fire


diff2.a <- effect1 %>%
  
  mutate(diff2a_mild = mild_high - mild_low,
         diff2a_severe = severe_high - severe_low) %>%
  
  select(starts_with("diff2a"))

diff3.a <- effect1 %>%
  
  mutate(diff3a_mild = (mild_high - mild_low) / mild_low * 100,
         diff3a_severe = (severe_high - severe_low) / severe_low * 100) %>%
  
  select(starts_with("diff3a"))

## diff severe conditions

diff3.s <- effect1 %>%
  
  mutate(diff3s_mild = (severe_high - mild_low) / mild_low * 100) %>%
  
  select(starts_with("diff3s"))

```





```{r}
# convert to long format for ggplot
dat.gg1 <- diff1 %>%
  tidyr::gather(var, diff1) %>%
  mutate(var = factor(str_replace(var, "diff1_", ""))) %>%
  mutate(var = factor(str_replace(var, "_", "/"))) %>%
  mutate(var = factor(var, levels = c("MD/LF", "MD/HF", "SD/LF", "SD/HF"), 
                           labels = c("MD/LF", "MD/HF", "SD/LF", "SD/HF")))


x.stats1 <- dat.gg1 %>%
  group_by(var) %>%
    summarize(mid = median(diff1),
            lwr95 = hpdi.vec(diff1, 0.95)[1],
            upr95 = hpdi.vec(diff1, 0.95)[2],
            lwr50 = hpdi.vec(diff1, 0.50)[1],
            upr50 = hpdi.vec(diff1, 0.50)[2])

# convert to long format for ggplot
dat.gg2 <- diff2 %>%
  tidyr::gather(var, diff2) %>%
  mutate(var = factor(str_replace(var, "diff2_", ""))) %>%
  mutate(var = factor(str_replace(var, "_", "/")))


  
x.stats2 <- dat.gg2 %>%
  group_by(var) %>%
    summarize(mid = median(diff2),
            lwr95 = hpdi.vec(diff2, 0.95)[1],
            upr95 = hpdi.vec(diff2, 0.95)[2],
            lwr50 = hpdi.vec(diff2, 0.50)[1],
            upr50 = hpdi.vec(diff2, 0.50)[2]) %>%
      mutate(var = factor(var, levels = c("low", "high"), 
                             labels = c("low", "high")))

# convert to long format for ggplot
dat.gg3 <- diff3 %>%
  tidyr::gather(var, diff3) %>%
  mutate(var = factor(str_replace(var, "diff3_", ""))) %>%
  mutate(var = factor(str_replace(var, "_", "/")))


  
x.stats3<- dat.gg3 %>%
  group_by(var) %>%
    summarize(mid = median(diff3),
            lwr95 = hpdi.vec(diff3, 0.95)[1],
            upr95 = hpdi.vec(diff3, 0.95)[2],
            lwr50 = hpdi.vec(diff3, 0.50)[1],
            upr50 = hpdi.vec(diff3, 0.50)[2])

# convert to long format for ggplot
dat.gg2.a <- diff2.a %>%
  tidyr::gather(var, diff2a) %>%
  mutate(var = factor(str_replace(var, "diff2a_", ""))) %>%
  mutate(var = factor(str_replace(var, "_", "/")))


  
x.stats2.a <- dat.gg2.a %>%
  group_by(var) %>%
    summarize(mid = median(diff2a),
            lwr95 = hpdi.vec(diff2a, 0.95)[1],
            upr95 = hpdi.vec(diff2a, 0.95)[2],
            lwr50 = hpdi.vec(diff2a, 0.50)[1],
            upr50 = hpdi.vec(diff2a, 0.50)[2])

# convert to long format for ggplot
dat.gg3.a <- diff3.a %>%
  tidyr::gather(var, diff3a) %>%
  mutate(var = factor(str_replace(var, "diff3a_", ""))) %>%
  mutate(var = factor(str_replace(var, "_", "/")))


  
x.stats3.a <- dat.gg3.a %>%
  group_by(var) %>%
    summarize(mid = median(diff3a),
            lwr95 = hpdi.vec(diff3a, 0.95)[1],
            upr95 = hpdi.vec(diff3a, 0.95)[2],
            lwr50 = hpdi.vec(diff3a, 0.50)[1],
            upr50 = hpdi.vec(diff3a, 0.50)[2])

# convert to long format for ggplot
dat.gg3.s <- diff3.s %>%
  tidyr::gather(var, diff3s) %>%
  mutate(var = factor(str_replace(var, "diff3s_", ""))) %>%
  mutate(var = factor(str_replace(var, "_", "/")))


  
x.stats3.s <- dat.gg3.s %>%
  group_by(var) %>%
    summarize(mid = median(diff3s),
            lwr95 = hpdi.vec(diff3s, 0.95)[1],
            upr95 = hpdi.vec(diff3s, 0.95)[2],
            lwr50 = hpdi.vec(diff3s, 0.50)[1],
            upr50 = hpdi.vec(diff3s, 0.50)[2])


```


```{r fig.height = 3, fig.width = 3}


rhg_cols2 <- c("MD/LF" = "#1b9e77", "MD/HF" = "#d95f02", "SD/LF" = "#7570b3", "SD/HF" = "#e7298a")


My_Theme = theme(
  plot.title = element_text(size = 11.5, face = "bold", hjust = 0.5),
  axis.title.y = element_text(size = 11.5, face = "bold"),
  axis.text.y = element_text(size = 9.5, margin = unit(c(0.1, 0.1, 0.1, -0.2), "cm")),
  axis.text.x = element_text(size = 10.5, vjust = 0.9, hjust = 0.9, margin = unit(c(0.15, 0.1, 0.1, 0.1), "cm"), angle = 45),
  axis.title.x = element_text(size = 11.5, face = "bold", vjust = -1.8),
  strip.text.x = element_text(size = 10.5),
  strip.text.y = element_text(size = 10.5),
  strip.text = element_text(size = 10.5),
  strip.background = element_blank(),
  panel.background = element_blank(),
  strip.placement = "inside",
  axis.ticks.length = unit(-0.07, "cm"),
  axis.ticks = element_line(size = 0.8),
  panel.grid.minor.x = element_blank(),
  panel.grid.major.x = element_blank(),
  panel.grid.minor.y = element_blank(),
  panel.grid.major.y = element_blank(),
  legend.position = "bottom",
  legend.title = element_text(size = 8.5, hjust = 0.6, face = "bold"),
  legend.text = element_text(size = 7.5),
  legend.key.width = unit(0.5, "cm"),
  legend.background = element_blank(),
  plot.margin = unit(c(2.5, 4, 4.5, 4), "pt"))



WSF.replace_mag_jags <- ggplot(data = dat.gg1, aes (x = var)) +
  
 My_Theme +
  
  
  geom_linerange(data = x.stats1, aes(ymin = lwr95, ymax = upr95),
               size = 0.5) +
 
  geom_linerange(data = x.stats1, aes(ymin = lwr50, ymax = upr50),
               size = 5, show.legend = FALSE) +
  
  geom_linerange(data = x.stats1, aes(ymin = lwr50+0.3, ymax = upr50-0.3, color = var),
               size = 4, show.legend = FALSE) +
 
 scale_color_manual(values = rhg_cols2) +
 
  labs(y = "", x = "") +
  
  
  geom_hline(yintercept = 0, linetype = "dotted") +
  
   ggsave("WSF.replace_mag_jags.png", width = 3.4, height = 3)

WSF.replace_mag_jags
 
```


Probability 

```{r}

means <- dat.gg1 %>%
  group_by(var) %>%
  summarize(prob = mean(diff1))

knitr::kable(means, digits = 3)

```

```{r}
x <- dat.gg1 %>%
  group_by(var) %>%
  
  summarize(lwr95 = hpdi.vec(diff1, 0.95)[1],
            lwr50 = hpdi.vec(diff1, 0.5)[1],
            mid = median(diff1),
            upr50 = hpdi.vec(diff1, 0.5)[2],
            upr95 = hpdi.vec(diff1, 0.95)[2])

knitr::kable(x, digits = 3)
```













```{r}
### WSF probability of decline
apply(effect1, 2, function(x) mean(x < 0))
```



diff drought num

```{r}

dat.gg2 %>%
  group_by(var) %>%
  summarize(prob = median(diff2))

```

diff fire num

```{r}

dat.gg2.a %>%
  group_by(var) %>%
  summarize(prob = median(diff2a))

```




